!
! Test program for "f_get_coeff.F90"
! Ken-Ichi Ishikawa [ishikawa[at]theo.phys.sci.hiroshima-u.ac.jp]
!
! See also: 
!  H. Haramoto, M. Matsumoto, T. Nishimura, F. Panneton, and P. L'Ecuyer, 
!   ``Efficient Jump Ahead for F_2-Linear Random Number Generators'', 
!  GERAD Report G-2006-62. INFORMS Journal on Computing, 20, 3 (2008), 385-390. 
!
!
! Copyright (c) 2010, Ken-Ichi Ishikawa [ishikawa[at]theo.phys.sci.hiroshima-u.ac.jp]
! All rights reserved.
! 
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions are
! met:
! 
! * Redistributions of source code must retain the above copyright
!   notice, this list of conditions and the following disclaimer. 
!   
! * Redistributions in binary form must reproduce the above copyright
!   notice, this list of conditions and the following disclaimer listed
!   in this license in the documentation and/or other materials
!   provided with the distribution.
!   
! * Neither the name of the copyright holders nor the names of its
!   contributors may be used to endorse or promote products derived from
!   this software without specific prior written permission.
!   
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
! A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
! OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
! SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
! LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
! DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
! THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  
! (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
! OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
! 

!#define _MT521_
#define _MT19937_

program f_jump_coeff
  use mt_kind_defs
  implicit none
#ifdef _MT521_
  !
  ! Mersenne Twister parameters (MT521)
  ! Generated by Dynamic Creator (dcmt0.6.1)
  ! [http:!www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/DC/dc.html]
  !
  integer(INT32), parameter :: nn = 17
  integer(INT32), parameter :: mm =  8
  integer(INT32), parameter :: rr = 23
  integer(INT32), parameter :: ww = 32
  integer(INT32), parameter avec = -2111700990
#endif

#ifdef _MT19937_
  !
  ! Mersenne Twister parameters (MT19937)
  ! Taken from 
  ! [http:!www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c]
  !
  integer(INT32), parameter :: nn = 624
  integer(INT32), parameter :: mm = 397
  integer(INT32), parameter :: rr = 31
  integer(INT32), parameter :: ww = 32
  integer(INT32), parameter :: avec = Z'9908b0df'
#endif
  integer(INT32), parameter :: period = nn*ww-rr

  !
  ! jump ahead steps exp. and id : (id)*2^nj steps;
  !
#ifdef _DEBUG_
  integer(INT32), parameter :: nj = 256
#else
  integer(INT32), parameter :: nj = 20
#endif
  integer(INT32), parameter :: id = 31

  !
  ! jump polynomial coefficients pp (GF(2)[x])
  !
  integer(INT32) :: pp(0:nn-1)

  !
  ! bit size of pp,  nb = (deg(pp))+1
  !
  integer(INT32) :: nb

  !
  ! array size
  !
  integer(INT32) :: nar

  integer(INT32) :: i
  character(256) :: str,str2
  nar = nn

  !
  ! compute pp via g(x) = x^(id*2^nj) mod phi(x)
  !
  !  phi(x) : characteristic polynomial for MT(nn,mm,rr,ww,avec)
  !           (computed in get_coeff_)
  !
  !  pp[] : g(x) = p(0) + p(1) x + p(2) x^2 ....+ p(nb-1) x^(nb-1)
  !       : p(i) => converted unsigned int vector pp[], 
  !       : (nb <= 32*nn)
  !
  call f_get_coeff(nn,mm,rr,ww,avec,nj,id,pp,nb);

  !
  ! Print Fortran90 style code.
  !
  write(str,*)period
  write(*,'("! MT",A)')TRIM(ADJUSTL(str))
  write(str,*)id
  write(str2,*)nj
  write(*,'("! Jump Ahead ",A,"*2^",A," steps coefficnents")')TRIM(ADJUSTL(str)),TRIM(ADJUSTL(str2))
  write(str,*)id
  write(*,'("  integer, parameter :: id  = ",A)')TRIM(ADJUSTL(str))
  write(str,*)nj
  write(*,'("  integer, parameter :: nj  = ",A)')TRIM(ADJUSTL(str))
  write(str,*)nb
  write(*,'("  integer, parameter :: nb  = ",A)')TRIM(ADJUSTL(str))
  write(str,*)nar
  write(*,'("  integer, parameter :: nar = ",A)')TRIM(ADJUSTL(str))
  write(*,'("  integer :: p(0:nar-1)")')
  write(*,'("  p(:)=0")')
  do i=0,nar-1
    write(str,*)i
    write(str2,'(z8)')pp(i)
    call up2lw(str2)
    write(*,'("  p(",A,")=Z''",A,"''")')TRIM(ADJUSTL(str)),TRIM(ADJUSTL(str2))
  enddo

  stop

contains

subroutine up2lw(buf)
  implicit none
  character(len=*) :: buf
  integer(INT32) :: i,n2
  n2=len(buf)
  do i=1,n2
    if(ichar(buf(i:i)) >= 65 .and. ichar(buf(i:i)) <= 90) &
 &      buf(i:i)=char(ichar(buf(i:i))+32)
  enddo
  return
end subroutine

end program
